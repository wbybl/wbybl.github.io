<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wbybl.github.io</id>
    <title>Gridea</title>
    <updated>2020-02-09T06:22:07.010Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wbybl.github.io"/>
    <link rel="self" href="https://wbybl.github.io/atom.xml"/>
    <logo>https://wbybl.github.io/images/avatar.png</logo>
    <icon>https://wbybl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[CF346D 【Robot Control】]]></title>
        <id>https://wbybl.github.io/post/cf346d-robot-control</id>
        <link href="https://wbybl.github.io/post/cf346d-robot-control">
        </link>
        <updated>2020-02-09T05:00:17.000Z</updated>
        <content type="html"><![CDATA[<p>这道题我们老师上课讲了，回来琢磨了琢磨，还是不太会，又借鉴了一下<a href="https://www.cnblogs.com/huibixiaoxing/p/7715898.html">博客</a></p>
<p>话说这道题真坑，首先显然是可以dp的，方程为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[u]=min(min(dp[v]+1),max(dp[v]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>这里dp[i]表示第i个点到终点需要的指令数量，</p>
<p>其实这个方程是可以直接 BFS 来算的...</p>
<p>注意到 min(dp(v) + 1) 实际上就是一个边权为 1 的最短路, 也就是 BFS;</p>
<p>而考虑后一项 maxfdp(v)g, 其实是在 BFS 时最后一个更新它的节点去更新它时没有代价.<br>
因为 BFS 的正确性要求队列中的元素距离是不降的, 所以一旦<br>
某个节点被最后一个点更新, 那么我们需要把它加入队首而非队尾.<br>
这个做法是 O(N + M) 的, 因为每个节点我们只需用它更新一次. 一样的道理, 每个点只会入队至多两次</p>
<p>这里我们借助spfa来完成dp</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
int dp[2000000], head[1100000], head2[1100000], len, len2;
struct edge{
	int v, fail;
	edge(){}
	edge(int a, int c){
		v = a;
		fail = c;
	}
}e[2200000],e2[2200000];
void add(int a, int b){
	e[len] = edge(b, head[a]);
	head[a] = len++;
}
void Add(int a, int b){
	e2[len2] = edge(a, head2[b]);
	head2[b] = len2++;
}
int vis[2200000];
queue&lt;int&gt; q;
int main(){
	ios::sync_with_stdio(0);
	memset(head, -1, sizeof(head));
	memset(head2, -1, sizeof(head2));
	int n, m, s, t;
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1; i &lt;= m; i++){
		int x, y, z;
		cin &gt;&gt; x &gt;&gt; y;
		add(x, y);
		Add(x, y);//建正图，反图，方便dp
	} 
	cin &gt;&gt; s &gt;&gt; t;
	for(int i = 1; i &lt;= n + 20; i++){//初始化
		dp[i] = 1147483646;
	}
	vis[t] = 1;
	dp[t] = 0;
	q.push(t);
	while(!q.empty()){//spfa模板稍加改动
		int now = q.front();
		q.pop();
		vis[now] = 0;
      //这里的两个for就分别对应前面转移方程的两种情况
		for(int i = head2[now]; ~i; i = e2[i].fail){
			if(dp[e2[i].v] &gt; dp[now] + 1){
				dp[e2[i].v] = dp[now] + 1;
				if(!vis[e2[i].v]){
					vis[e2[i].v] = 1;
					q.push(e2[i].v);
				}
			} 
		}
		int Max = 0;
		for(int i = head[now]; ~i; i = e[i].fail){
			Max = max(Max, dp[e[i].v]);
		}
		if(dp[now] &gt; Max){
			dp[now] = Max;
			if(!vis[now]){
				vis[now] = 1;
				q.push(now);
			}
		}
	}
	if(dp[s] != 1147483646)
	cout &lt;&lt; dp[s] &lt;&lt; endl;
	else cout &lt;&lt; -1 &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1074 靶形数独]]></title>
        <id>https://wbybl.github.io/post/p1074-ba-xing-shu-du</id>
        <link href="https://wbybl.github.io/post/p1074-ba-xing-shu-du">
        </link>
        <updated>2020-02-09T04:58:45.000Z</updated>
        <content type="html"><![CDATA[<p>这道题是一道dfs好题，很多人在题解里用了各种剪枝，以及一些奇奇怪怪的优化，还有大佬用的舞蹈链算法，蒟蒻不会舞蹈链，剪枝的效果也不是很好，只能用一些优化来过这道题了。</p>
<p>这道题虽然已经有很多题解了，但是我还是来交题解的原因是我觉得我的代码跑的，可以给大家提供一些关于搜索顺序的思路，<s>希望管理员不要认为我这是重复的解法</s>。不过我敢保证，我的代码跑的一定比除了打表题解以外的题解跑的快。</p>
<p><s>说实话，这题普通剪枝也可以水过</s>，但是既然我们要追求速度，就不能仅仅局限于最优性、可行性剪枝。画了几张图以后发现一个规律，先搜索约束个数多的点，效率最高。这里的约束个数，就是这个点所在行、列、宫已经填好的数的个数之和。（具体内容见下图）</p>
<p>所以我们就得到了一个思路，与处理好搜索顺序，也就是统计每个点的约束个数，先找到最多的，然后记录下来，假设它已经填好（把他所在的行、列、宫的约束个数加一），然后继续找第二多的就好了。最后按照这个顺序在每次dfs结束后找到下一个填数的点，就ok了，这样可以达到总效率888ms,已经非常快了。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/pic/73082.png" alt="大家可以看一下，第一个就是预处理后的搜索树，第二个是随便搜，差距一目了然" loading="lazy"></figure>
<p>显然先搜索可能性为2的节点比先搜索可能性为4的搜索树小很多，当可能性扩大到9*9=81时，差距会十分明显，效率自然也就高很多了</p>
<p>很多细节详见代码注释。</p>
<p>因为很多人只是预处理了列，按照列每次处理9个，所以效率没有我这种写法高</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int ans[13][13];
int cntc[13],cntr[13],cntb[13];
int belong(int x,int y){//判断x,y属于哪一个宫
	int h,l;
	if(x&lt;=3)h=1;
	else if(x&lt;=6)h=2;
	else h=3;
	if(y&lt;=3)l=1;
	else if(y&lt;=6)l=2;
	else l=3;
	return (h-1)*3+l;
}
pair&lt;int,int&gt; s[100];
int cnt=0;
int ANS=0;
int v[10][10]={{0,0,0,0,0,0,0,0,0,0},{0,6,6,6,6,6,6,6,6,6},{0,6,7,7,7,7,7,7,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,9,10,9,8,7,6,},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,7,7,7,7,7,7,6},{0,6,6,6,6,6,6,6,6,6}};
//记录每一个点的分数
void calc(){
	int tot=0;
	for(int i=1;i&lt;=9;i++)
		for(int j=1;j&lt;=9;j++)
			tot+=ans[i][j]*v[i][j];
	ANS=max(ANS,tot);
}//搜索完成后计算答案的函数
int col[20][20],row[20][20],block[20][20];
void dfs(int x,int y,int now){//简单的搜索，按照我们在main函数中预处理的pair&lt;int,int&gt; s的顺序搜索，这样效率最高
	if(now==cnt+1)calc();
	int b=belong(x,y);
	for(int i=1;i&lt;=9;i++){
		if(!col[x][i]&amp;&amp;!row[y][i]&amp;&amp;!block[b][i]){//判断是不是可行
			col[x][i]=row[y][i]=block[b][i]=1;//标记访问
			ans[x][y]=i;
			dfs(s[now+1].first,s[now+1].second,now+1);
			col[x][i]=row[y][i]=block[b][i]=ans[x][y]=0;//回溯
		}
	}
}
int vis[20][20];
int main(){
	for(int i=1;i&lt;=9;i++)
		for(int j=1;j&lt;=9;j++){
			cin&gt;&gt;ans[i][j];
			if(ans[i][j]!=0)vis[i][j]=1,cntc[i]++,cntr[j]++,cntb[belong(i,j)]++,col[i][ans[i][j]]=1,row[j][ans[i][j]]=1,block[belong(i,j)][ans[i][j]]=1;		
			else cnt++;
		}//这里为预处理每一个点在行、列、宫中的限制个数
	for(int k=1;k&lt;=cnt;k++){
		int Max=0,px,py;
		for(int i=1;i&lt;=9;i++
			for(int j=1;j&lt;=9;j++)
				if(cntc[i]+cntr[j]+cntb[belong(i,j)]&gt;Max&amp;&amp;!vis[i][j])
				Max=cntc[i]+cntr[j]+cntb[belong(i,j)],px=i,py=j;
		s[k]=make_pair(px,py);
      //找到可能性最少的点，并假设他已经填好，继续找下一个   
		cntc[px]++,cntr[py]++,cntb[belong(px,py)]++;
		vis[px][py]=1;
	//	cout&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;px&lt;&lt;&quot; &quot;&lt;&lt;py&lt;&lt;endl;	
	}
	dfs(s[1].first,s[1].second,1);//从第一个开始搜索
	if(ANS!=0)
	cout&lt;&lt;ANS&lt;&lt;endl;
	else cout&lt;&lt;-1&lt;&lt;endl;//输出答案
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UVA1343 【旋转游戏 The Rotation Game】]]></title>
        <id>https://wbybl.github.io/post/uva1343-xuan-zhuan-you-xi-the-rotation-game</id>
        <link href="https://wbybl.github.io/post/uva1343-xuan-zhuan-you-xi-the-rotation-game">
        </link>
        <updated>2020-02-09T04:58:15.000Z</updated>
        <content type="html"><![CDATA[<p>这道题可以说是ida*的“模板&quot;题</p>
<p>ida*就是迭代加深搜索+估价，枚举层数，开始dfs，到枚举的层数就停止，这样的好处是有bfs的顺序（速度），剩下了bfs的空间。</p>
<p>什么是估价呢，估价就是计算一个当前方案的价值，找一个比较理想的先搜索，这样理论上可以加速搜索的过程，一个好的估价函数可以让你的搜索直接找到正解（虽然不大可能）</p>
<p>这道题就是将上下左右的移动当成一种状态，每次搜索动哪一根，估价函数为中间的八个格子有几个相等的（原因是题目求最少几次可以让中间的变成一样的数），每次迭代加深就可以了。</p>
<p>这题有很多细节，比如说题目中的读入非常玄学，按照1~24的顺序从上往下，从左往右读，这就需要一些处理来计算出每一根上面的数存在哪里。其他细节详见代码注释。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//            1     2 
//            3     4
//      5  6  7  8  9 10 11
//			  12    13			
//      14 15 16 17 18 19 20
//            21    22
//            23    24   随手打下的草稿，用来对照题目中的输入，处理细节
int zhong[8]={7,8,9,12,13,16,17,18};//记录中心块读入的下标
int a[100];
int b[8][7]={{1,3,7,12,16,21,23},{2,4,9,13,18,22,24},{11,10,9,8,7,6,5},{20,19,18,17,16,15,14},
{24,22,18,13,9,4,2},{23,21,16,12,7,3,1},{14,15,16,17,18,19,20},{5,6,7,8,9,10,11}};//记录8种操作挪动的下标
int back[8]={5,4,7,6,1,0,3,2};
int count(int x){//数在8个中心块种有多少个x
	int cnt=0;
	for(int i=0;i&lt;=7;i++)if(a[zhong[i]]==x)cnt++;
	return cnt;
}
int calc(){//算出中心块中有多少个1,2,3，求出价值（估价部分）
	return 8-max(max(count(1),count(2)),count(3));
}
void move(int n){//使用第n种操作移动，这里用到了之前处理的每一根上面的下标
	int q=a[b[n][0]];
	for(int i=1;i&lt;=6;i++){//去掉最后一个，共6个
		a[b[n][i-1]]=a[b[n][i]];
	}
	a[b[n][6]]=q;//注意细节，最后一个需要单独赋值
}
char c[100000];
void output(){//这个是调试用的输出函数，挺复杂的，挑不出来的同学们可以用他输出调试
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[1]&lt;&lt;&quot;     &quot;&lt;&lt;a[2]&lt;&lt;endl;
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[3]&lt;&lt;&quot;     &quot;&lt;&lt;a[4]&lt;&lt;endl;
	cout&lt;&lt;a[5]&lt;&lt;&quot;  &quot;&lt;&lt;a[6]&lt;&lt;&quot;  &quot;&lt;&lt;a[7]&lt;&lt;&quot;  &quot;&lt;&lt;a[8]&lt;&lt;&quot;  &quot;&lt;&lt;a[9]&lt;&lt;&quot;  &quot;&lt;&lt;a[10]&lt;&lt;&quot;  &quot;&lt;&lt;a[11]&lt;&lt;endl;
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[12]&lt;&lt;&quot;     &quot;&lt;&lt;a[13]&lt;&lt;endl;
	cout&lt;&lt;a[14]&lt;&lt;&quot;  &quot;&lt;&lt;a[15]&lt;&lt;&quot;  &quot;&lt;&lt;a[16]&lt;&lt;&quot;  &quot;&lt;&lt;a[17]&lt;&lt;&quot;  &quot;&lt;&lt;a[18]&lt;&lt;&quot;  &quot;&lt;&lt;a[19]&lt;&lt;&quot;  &quot;&lt;&lt;a[20]&lt;&lt;endl;
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[21]&lt;&lt;&quot;     &quot;&lt;&lt;a[22]&lt;&lt;endl;
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[23]&lt;&lt;&quot;     &quot;&lt;&lt;a[24]; 
}
bool dfs(int now,int last,int limit){//搜索函数，返回值是搜没搜到解，如果搜到了解，答案就是迭代加深的层数
	//output();
	//cout&lt;&lt;endl&lt;&lt;&quot;-------------------------------&quot;&lt;&lt;endl;
	if(calc()==0){//如果全部一样，就有解
		return 1;
	}
	if(calc()+now&gt;limit)return 0;//剪枝，如果最少步数还超过了层数限制，就没有解了
	for(int i=0;i&lt;=7;i++){//枚举是哪一种移动
	//	cout&lt;&lt;(char)(i+'A')&lt;&lt;endl;
		//if(i==last)continue;
		move(i);
		c[now+1]=i+'A';//记录移动方案，准备输出
		if(dfs(now+1,i,limit))return 1;//如果搜到了解，返回true
		move(back[i]); //这里要回溯，很重要的细节，back[i]表示i的逆操作
	}
	return 0;
}
int main(){
	//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    while(1){
		cin&gt;&gt;a[1];
		if(a[1]==0)return 0;
		for(int i=2;i&lt;=24;i++)cin&gt;&gt;a[i];
		if(calc()==0)cout&lt;&lt;&quot;No moves needed&quot;&lt;&lt;endl&lt;&lt;a[zhong[1]]&lt;&lt;endl;//细节，如果不需要移动，直接输出
		else{
			int ans=1;
			while(1){//迭代加深，枚举层数
				if(dfs(0,-1,ans)){//如果在ans层内有解，答案为ans
					break;
				}
				ans++;
			}
			for(int i=1;i&lt;=ans;i++)cout&lt;&lt;c[i];//输出移动的方案
			cout&lt;&lt;endl&lt;&lt;a[zhong[1]]&lt;&lt;endl;//输出中心块颜色
		}	
    }
}
</code></pre>
]]></content>
    </entry>
</feed>