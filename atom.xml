<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wbybl.github.io</id>
    <title>Gridea</title>
    <updated>2020-02-09T07:07:46.050Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wbybl.github.io"/>
    <link rel="self" href="https://wbybl.github.io/atom.xml"/>
    <logo>https://wbybl.github.io/images/avatar.png</logo>
    <icon>https://wbybl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[luoguP4047[JSOI2010]éƒ¨è½åˆ’åˆ†]]></title>
        <id>https://wbybl.github.io/post/luogup4047jsoi2010bu-luo-hua-fen</id>
        <link href="https://wbybl.github.io/post/luogup4047jsoi2010bu-luo-hua-fen">
        </link>
        <updated>2020-02-09T07:00:47.000Z</updated>
        <content type="html"><![CDATA[<p>ç¥å¥‡çš„æœ€å°ç”Ÿæˆæ ‘é¢˜ğŸ˜€<br>
<img src="https://wbybl.github.io/post-images/1581231705702.png" alt="" loading="lazy"><br>
n^2æšä¸¾æ¯ä¸€ä¸ªç‚¹ï¼Œè®¡ç®—å‡ºæ¯ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»<br>
å› ä¸ºæ²¡åˆå¹¶ä¸€æ¬¡ï¼Œå°±ä¼šå‡å°‘ä¸€ä¸ªéƒ¨è½ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åˆå¹¶n-kæ¬¡<br>
æ ¹æ®è´ªå¿ƒçš„æ€æƒ³ï¼Œæ¯æ¬¡æˆ‘ä»¬éœ€è¦æŒ‘å‡ºè·ç¦»æœ€è¿‘çš„ä¸¤ä¸ªç‚¹åˆå¹¶ï¼Œå¦åˆ™ç­”æ¡ˆå°±ä¼šå˜å°<br>
æ‰€ä»¥æˆ‘ä»¬é¢„å…ˆæ’ä¸ªåºï¼Œç„¶åæ¯æ¬¡ä»å°åˆ°å¤§æ‰¾æ²¡æœ‰è¿æ¥èµ·æ¥çš„ç‚¹ï¼Œåˆå¹¶å³å¯<br>
æ˜¯ä¸æ˜¯ç‰¹åˆ«åƒkruskal<br>
æ‰€ä»¥ç›´æ¥è·‘kruskalæ¨¡æ¿ï¼Œæ‰¾å‡ºn-kæ¡è¾¹å³å¯ï¼Œæœ€åè¾“å‡ºä¸‹ä¸€æ¡æ²¡æœ‰åˆå¹¶çš„è¾¹æƒï¼Œä¹Ÿå°±æ˜¯æœ€å°è·ç¦»</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#include&lt;cstdio&gt;
using namespace std;
int n,m;
int x[1001000],y[1000100];
struct edge{
    int a,b;
    double c;
}e[2001000];
double dis(int x,int y,int x1,int y1){
    return sqrt((x-x1)*(x-x1)+(y-y1)*(y-y1));
}
bool cmp(edge a,edge b){
    return a.c&lt;b.c;
}
int fa[1001000];
int get(int x){
    if(fa[x]==x)return x;
    return fa[x]=get(fa[x]);
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;x[i]&gt;&gt;y[i];
        fa[i]=i;
    }
    int cnt=0;
    for(int i=1;i&lt;=n;i++){
        for(int j=i+1;j&lt;=n;j++){
            e[++cnt].a=i;
            e[cnt].b=j;
            e[cnt].c=dis(x[i],y[i],x[j],y[j]);
        }
    }
    sort(e+1,e+cnt+1,cmp);
    int tot=0;
    for(int i=1;i&lt;=cnt;i++){
        //cout&lt;&lt;e[i].a&lt;&lt;&quot; &quot;&lt;&lt;e[i].b&lt;&lt;&quot; &quot;&lt;&lt;e[i].c&lt;&lt;endl;
        int A=get(e[i].a),B=get(e[i].b);
        if(A!=B){
            tot++;
            fa[A]=B;
        }
        if(tot==n-m+1){
            printf(&quot;%.2lf&quot;,e[i].c);            
            return 0;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[luogu P3358 æœ€é•¿kå¯é‡åŒºé—´é›†é—®é¢˜]]></title>
        <id>https://wbybl.github.io/post/luogu-p3358-zui-chang-k-ke-chong-qu-jian-ji-wen-ti</id>
        <link href="https://wbybl.github.io/post/luogu-p3358-zui-chang-k-ke-chong-qu-jian-ji-wen-ti">
        </link>
        <updated>2020-02-09T06:55:18.000Z</updated>
        <content type="html"><![CDATA[<p>æœ€å¤§è´¹ç”¨æœ€å¤§æµï¼Œå»ºæ¨¡æ–¹æ³•ï¼š</p>
<p>é»‘çº¿ã€ç´«çº¿éƒ½æ˜¯æµé‡kï¼Œè´¹ç”¨0ï¼Œä¿éšœå›¾çš„è¿é€šæ€§ï¼Œä»¥åŠåªèƒ½èµ°kæ¬¡</p>
<p>çº¢çº¿ä»£è¡¨ä¸€ä¸ªç»™å®šçš„åŒºé—´ï¼Œæµé‡1ä»£è¡¨åªèƒ½å–ä¸€æ¬¡ï¼Œè´¹ç”¨ä¸ºåŒºé—´é•¿åº¦ä»£è¡¨èµ°è¿‡è¿™æ¡åŒºé—´ï¼Œå¯ä»¥è·å¾—åŒºé—´é•¿åº¦çš„ä»·å€¼<br>
<img src="https://wbybl.github.io/post-images/1581231481297.png" alt="" loading="lazy"><br>
è·‘æœ€å¤§è´¹ç”¨æœ€å¤§æµï¼ˆå¼€å§‹æ—¶æŠŠè¾¹æƒå–åï¼Œè·‘æœ€å°è´¹ç”¨æœ€å¤§æµï¼Œç„¶åå†å–åï¼‰</p>
<p>éœ€è¦ç¦»æ•£åŒ–ğŸ˜‚</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct edge{
    long long v,w,cost,fail;
    edge(){
    }
    edge(long long a,long long b,long long c,long long d){
        v=a;
        w=b;
        cost=c;
        fail=d;
    }
}e[200100];
long long n,k,s,t,m,incf[200100],pre[200100],vis[200100],dis[200100],head[200100],len,last[200100];
long long Left[200100],Right[200010],u[200100],cnt,U[200100],val[200100];
void add(long long x,long long y,long long z,long long c){
    e[len]=edge(y,z,c,head[x]);
    head[x]=len++;
    e[len]=edge(x,0,-c,head[y]);
    head[y]=len++;
}
bool spfa(){
    queue&lt;long long&gt; q;
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis)); 
    q.push(s);
    dis[s]=0;
    vis[s]=1;
    incf[s]=(long long)1e17;
    while(!q.empty()){
//        cout&lt;&lt;q.front()&lt;&lt;endl;
        long long now=q.front();
        vis[now]=0;
        q.pop();
        for(long long i=head[now];~i;i=e[i].fail){
        //    cout&lt;&lt;i&lt;&lt;endl;
            if(!e[i].w)continue;
            if(dis[e[i].v]&gt;dis[now]+e[i].cost){
                dis[e[i].v]=dis[now]+e[i].cost;
                incf[e[i].v]=min(incf[now],e[i].w);
                pre[e[i].v]=i;
                last[e[i].v]=now;
            //    cout&lt;&lt;&quot;pre of&quot;&lt;&lt;e[i].v&lt;&lt;&quot; is&quot;&lt;&lt;now&lt;&lt;endl;
                if(vis[e[i].v]==0){
                    vis[e[i].v]=1;
                    q.push(e[i].v);
                }
            }
        } 
    }
    //cout&lt;&lt;1&lt;&lt;endl;
    if(dis[t]&gt;=(long long)(1e17))return 0;
    else return 1;
}
long long maxflow=0;
long long ans=0;
long long inf=(long long)1e17;
void update(){
    //cout&lt;&lt;&quot;--------------------------&quot;&lt;&lt;endl;
    long long now=t;
    while(now!=s){
    //    cout&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;last[now]&lt;&lt;endl;
        long long i=pre[now];
        e[i].w-=incf[t];
        e[i^1].w+=incf[t];
        now=last[now];
    } 
    maxflow+=incf[t];
    ans+=dis[t]*incf[t];
    //cout&lt;&lt;ans&lt;&lt;endl;
//    cout&lt;&lt;ans&lt;&lt;endl;
}   
int main(){
    cin&gt;&gt;n&gt;&gt;k;
    memset(head,-1,sizeof(head)); 
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;Left[i]&gt;&gt;Right[i];
        u[++cnt]=Left[i];
        u[++cnt]=Right[i];
        val[i]=Right[i]-Left[i];
    }
    sort(u+1,u+cnt+1);
    int cnt1=0;
    for(int i=1;i&lt;=cnt;i++){
        if(u[i]!=u[i-1]){
            U[++cnt1]=u[i];
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=cnt1;j++){
            if(Left[i]==U[j])Left[i]=j;
            if(Right[i]==U[j])Right[i]=j;
        }
    }
    long long Max=0;
    for(int i=1;i&lt;=n;i++){
        Max=max(Max,Right[i]);
        add(Left[i],Right[i],1,-val[i]);
    }
    n=Max;
    s=0;
    t=Max+1;
    for(int i=1;i&lt;n;i++){
        add(i,i+1,k,0);
    }
    add(s,1,k,0);
    add(n,t,k,0);
    while(spfa())update();
    cout&lt;&lt;-ans&lt;&lt;endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3358 æœ€é•¿kå¯é‡åŒºé—´é›†é—®é¢˜]]></title>
        <id>https://wbybl.github.io/post/p3358-zui-chang-k-ke-chong-qu-jian-ji-wen-ti</id>
        <link href="https://wbybl.github.io/post/p3358-zui-chang-k-ke-chong-qu-jian-ji-wen-ti">
        </link>
        <updated>2020-02-09T06:55:18.000Z</updated>
        <content type="html"><![CDATA[<p>æœ€å¤§è´¹ç”¨æœ€å¤§æµï¼Œå»ºæ¨¡æ–¹æ³•ï¼š</p>
<p>é»‘çº¿ã€ç´«çº¿éƒ½æ˜¯æµé‡kï¼Œè´¹ç”¨0ï¼Œä¿éšœå›¾çš„è¿é€šæ€§ï¼Œä»¥åŠåªèƒ½èµ°kæ¬¡</p>
<p>çº¢çº¿ä»£è¡¨ä¸€ä¸ªç»™å®šçš„åŒºé—´ï¼Œæµé‡1ä»£è¡¨åªèƒ½å–ä¸€æ¬¡ï¼Œè´¹ç”¨ä¸ºåŒºé—´é•¿åº¦ä»£è¡¨èµ°è¿‡è¿™æ¡åŒºé—´ï¼Œå¯ä»¥è·å¾—åŒºé—´é•¿åº¦çš„ä»·å€¼<br>
<img src="https://wbybl.github.io/post-images/1581231481297.png" alt="" loading="lazy"><br>
è·‘æœ€å¤§è´¹ç”¨æœ€å¤§æµï¼ˆå¼€å§‹æ—¶æŠŠè¾¹æƒå–åï¼Œè·‘æœ€å°è´¹ç”¨æœ€å¤§æµï¼Œç„¶åå†å–åï¼‰</p>
<p>éœ€è¦ç¦»æ•£åŒ–ğŸ˜‚</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
struct edge{
    long long v,w,cost,fail;
    edge(){
    }
    edge(long long a,long long b,long long c,long long d){
        v=a;
        w=b;
        cost=c;
        fail=d;
    }
}e[200100];
long long n,k,s,t,m,incf[200100],pre[200100],vis[200100],dis[200100],head[200100],len,last[200100];
long long Left[200100],Right[200010],u[200100],cnt,U[200100],val[200100];
void add(long long x,long long y,long long z,long long c){
    e[len]=edge(y,z,c,head[x]);
    head[x]=len++;
    e[len]=edge(x,0,-c,head[y]);
    head[y]=len++;
}
bool spfa(){
    queue&lt;long long&gt; q;
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis)); 
    q.push(s);
    dis[s]=0;
    vis[s]=1;
    incf[s]=(long long)1e17;
    while(!q.empty()){
//        cout&lt;&lt;q.front()&lt;&lt;endl;
        long long now=q.front();
        vis[now]=0;
        q.pop();
        for(long long i=head[now];~i;i=e[i].fail){
        //    cout&lt;&lt;i&lt;&lt;endl;
            if(!e[i].w)continue;
            if(dis[e[i].v]&gt;dis[now]+e[i].cost){
                dis[e[i].v]=dis[now]+e[i].cost;
                incf[e[i].v]=min(incf[now],e[i].w);
                pre[e[i].v]=i;
                last[e[i].v]=now;
            //    cout&lt;&lt;&quot;pre of&quot;&lt;&lt;e[i].v&lt;&lt;&quot; is&quot;&lt;&lt;now&lt;&lt;endl;
                if(vis[e[i].v]==0){
                    vis[e[i].v]=1;
                    q.push(e[i].v);
                }
            }
        } 
    }
    //cout&lt;&lt;1&lt;&lt;endl;
    if(dis[t]&gt;=(long long)(1e17))return 0;
    else return 1;
}
long long maxflow=0;
long long ans=0;
long long inf=(long long)1e17;
void update(){
    //cout&lt;&lt;&quot;--------------------------&quot;&lt;&lt;endl;
    long long now=t;
    while(now!=s){
    //    cout&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;last[now]&lt;&lt;endl;
        long long i=pre[now];
        e[i].w-=incf[t];
        e[i^1].w+=incf[t];
        now=last[now];
    } 
    maxflow+=incf[t];
    ans+=dis[t]*incf[t];
    //cout&lt;&lt;ans&lt;&lt;endl;
//    cout&lt;&lt;ans&lt;&lt;endl;
}   
int main(){
    cin&gt;&gt;n&gt;&gt;k;
    memset(head,-1,sizeof(head)); 
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;Left[i]&gt;&gt;Right[i];
        u[++cnt]=Left[i];
        u[++cnt]=Right[i];
        val[i]=Right[i]-Left[i];
    }
    sort(u+1,u+cnt+1);
    int cnt1=0;
    for(int i=1;i&lt;=cnt;i++){
        if(u[i]!=u[i-1]){
            U[++cnt1]=u[i];
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=cnt1;j++){
            if(Left[i]==U[j])Left[i]=j;
            if(Right[i]==U[j])Right[i]=j;
        }
    }
    long long Max=0;
    for(int i=1;i&lt;=n;i++){
        Max=max(Max,Right[i]);
        add(Left[i],Right[i],1,-val[i]);
    }
    n=Max;
    s=0;
    t=Max+1;
    for(int i=1;i&lt;n;i++){
        add(i,i+1,k,0);
    }
    add(s,1,k,0);
    add(n,t,k,0);
    while(spfa())update();
    cout&lt;&lt;-ans&lt;&lt;endl;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[äºŒç»´å‡¸åŒ…æ¨¡æ¿ luoguP2742]]></title>
        <id>https://wbybl.github.io/post/er-wei-tu-bao-mo-ban-luogup2742</id>
        <link href="https://wbybl.github.io/post/er-wei-tu-bao-mo-ban-luogup2742">
        </link>
        <updated>2020-02-09T06:23:06.000Z</updated>
        <content type="html"><![CDATA[<p>é¢˜ç›®ï¼šç»™å®šä¸€äº›ç‚¹ï¼Œæ±‚èƒ½æŠŠæ‰€æœ‰è¿™äº›ç‚¹åŒ…å«åœ¨å†…çš„æœ€å°çš„å‡¸å¤šè¾¹å½¢</p>
<p>è§£æ³•ï¼šç®—æ³•ç«èµ›å…¥é—¨åˆ°è¿›é˜¶P283çš„Andrewç®—æ³•</p>
<p>ï¼ˆ1ï¼‰æŠŠæ‰€æœ‰è¿™äº›ç‚¹æŒ‰ç…§æ¨ªåæ ‡ä»å°åˆ°å¤§æ’åºï¼Œå¦‚æœxç›¸åŒï¼ŒæŒ‰ç…§yä»å°åˆ°å¤§æ’åº</p>
<p>ï¼ˆ2ï¼‰ä»å·¦åˆ°å³æ‰«ææ‰€æœ‰ç‚¹ï¼Œæ±‚ä¸‹å‡¸åŒ…ã€‚æ¯åˆ°è¾¾ä¸€ä¸ªç‚¹æ—¶åˆ¤æ–­ï¼Œå¦‚æœæ–°ç‚¹åœ¨ä¸‹å‡¸åŒ…å·¦å‰æ–¹ï¼ˆå‘é‡åˆ¤æ–­ï¼‰ï¼ŒåŠ å…¥ä¸‹å‡¸åŒ…ï¼Œå¦åˆ™å›æº¯ï¼ˆåˆ é™¤æœ€è¿‘åŠ å…¥çš„ï¼ŒçŸ¥é“è¿™ä¸ªæ–°ç‚¹åœ¨ä¸‹å‡¸åŒ…å·¦è¾¹ï¼Œå¹¶åŠ å…¥å‡¸åŒ…ï¼‰</p>
<p>ï¼ˆ3ï¼‰åŒç†æ±‚ä¸Šå‡¸åŒ…<br>
<img src="https://wbybl.github.io/post-images/1581229454759.png" alt="" loading="lazy"></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const double eps=1e-8;
int sgn(double x){
    if(fabs(x)&lt;eps)return 0;
    else return x&lt;0?-1:1;
}
struct Point{
    double x,y;
    Point(double X=0,double Y=0){
        x=X;
        y=Y;
    }
    Point operator +(Point B){
        return Point(x+B.x,y+B.y);
    }
    Point operator -(Point B){
        return Point(x-B.x,y-B.y);
    }
    Point operator *(double k){
        return Point(x*k,y*k);
    }
    Point operator /(double k){
        return Point(x/k,y/k);
    }
    bool operator ==(Point B){
        return sgn(x-B.x)==0&amp;&amp;sgn(y-B.y)==0;
    }
    bool operator &lt;(Point B){
        return sgn(x-B.x)&lt;0||(sgn(x-B.x)==0&amp;&amp;sgn(y-B.y&lt;0));
    }
}; 
typedef Point Vector;
double Cross(Vector A,Vector B){
    return A.x*B.y-A.y*B.x;
}
double Distance(Point A,Point B){
    return hypot(A.x-B.x,A.y-B.y);
}
int Convex_hull(Point *p,int n,Point *ch){
    sort(p,p+n);
    n=unique(p,p+n)-p;
    int v=0;
    for(int i=0;i&lt;n;i++){
        while(v&gt;1&amp;&amp;sgn(Cross(ch[v-1]-ch[v-2],p[i]-ch[v-2]))&lt;=0)
        v--;
        ch[v++]=p[i];
    }
    int j=v;
    for(int i=n-2;i&gt;=0;i--){
        while(v&gt;j&amp;&amp;sgn(Cross(ch[v-1]-ch[v-2],p[i]-ch[v-2]))&lt;=0)
        v--;
        ch[v++]=p[i];
    }
    if(n&gt;1)v--;
    return v;
}
Point p[11000],ch[11000];
int main(){
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    cin&gt;&gt;p[i].x&gt;&gt;p[i].y;
    int v=Convex_hull(p,n,ch);
    double ans=0;
    if(v==1)ans=0;
    else if(v==2)ans=Distance(ch[0],ch[1]);
    else{
        for(int i=0;i&lt;v;i++)
            ans+=Distance(ch[i],ch[(i+1)%v]);
        printf(&quot;%.2lf\n&quot;,ans);
    } 
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF346D ã€Robot Controlã€‘]]></title>
        <id>https://wbybl.github.io/post/cf346d-robot-control</id>
        <link href="https://wbybl.github.io/post/cf346d-robot-control">
        </link>
        <updated>2020-02-09T05:00:17.000Z</updated>
        <content type="html"><![CDATA[<p>è¿™é“é¢˜æˆ‘ä»¬è€å¸ˆä¸Šè¯¾è®²äº†ï¼Œå›æ¥ç¢ç£¨äº†ç¢ç£¨ï¼Œè¿˜æ˜¯ä¸å¤ªä¼šï¼Œåˆå€Ÿé‰´äº†ä¸€ä¸‹<a href="https://www.cnblogs.com/huibixiaoxing/p/7715898.html">åšå®¢</a></p>
<p>è¯è¯´è¿™é“é¢˜çœŸå‘ï¼Œé¦–å…ˆæ˜¾ç„¶æ˜¯å¯ä»¥dpçš„ï¼Œæ–¹ç¨‹ä¸º<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[u]=min(min(dp[v]+1),max(dp[v]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>è¿™é‡Œdp[i]è¡¨ç¤ºç¬¬iä¸ªç‚¹åˆ°ç»ˆç‚¹éœ€è¦çš„æŒ‡ä»¤æ•°é‡ï¼Œ</p>
<p>å…¶å®è¿™ä¸ªæ–¹ç¨‹æ˜¯å¯ä»¥ç›´æ¥ BFS æ¥ç®—çš„...</p>
<p>æ³¨æ„åˆ° min(dp(v) + 1) å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªè¾¹æƒä¸º 1 çš„æœ€çŸ­è·¯, ä¹Ÿå°±æ˜¯ BFS;</p>
<p>è€Œè€ƒè™‘åä¸€é¡¹ maxfdp(v)g, å…¶å®æ˜¯åœ¨ BFS æ—¶æœ€åä¸€ä¸ªæ›´æ–°å®ƒçš„èŠ‚ç‚¹å»æ›´æ–°å®ƒæ—¶æ²¡æœ‰ä»£ä»·.<br>
å› ä¸º BFS çš„æ­£ç¡®æ€§è¦æ±‚é˜Ÿåˆ—ä¸­çš„å…ƒç´ è·ç¦»æ˜¯ä¸é™çš„, æ‰€ä»¥ä¸€æ—¦<br>
æŸä¸ªèŠ‚ç‚¹è¢«æœ€åä¸€ä¸ªç‚¹æ›´æ–°, é‚£ä¹ˆæˆ‘ä»¬éœ€è¦æŠŠå®ƒåŠ å…¥é˜Ÿé¦–è€Œéé˜Ÿå°¾.<br>
è¿™ä¸ªåšæ³•æ˜¯ O(N + M) çš„, å› ä¸ºæ¯ä¸ªèŠ‚ç‚¹æˆ‘ä»¬åªéœ€ç”¨å®ƒæ›´æ–°ä¸€æ¬¡. ä¸€æ ·çš„é“ç†, æ¯ä¸ªç‚¹åªä¼šå…¥é˜Ÿè‡³å¤šä¸¤æ¬¡</p>
<p>è¿™é‡Œæˆ‘ä»¬å€ŸåŠ©spfaæ¥å®Œæˆdp</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
int dp[2000000], head[1100000], head2[1100000], len, len2;
struct edge{
	int v, fail;
	edge(){}
	edge(int a, int c){
		v = a;
		fail = c;
	}
}e[2200000],e2[2200000];
void add(int a, int b){
	e[len] = edge(b, head[a]);
	head[a] = len++;
}
void Add(int a, int b){
	e2[len2] = edge(a, head2[b]);
	head2[b] = len2++;
}
int vis[2200000];
queue&lt;int&gt; q;
int main(){
	ios::sync_with_stdio(0);
	memset(head, -1, sizeof(head));
	memset(head2, -1, sizeof(head2));
	int n, m, s, t;
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1; i &lt;= m; i++){
		int x, y, z;
		cin &gt;&gt; x &gt;&gt; y;
		add(x, y);
		Add(x, y);//å»ºæ­£å›¾ï¼Œåå›¾ï¼Œæ–¹ä¾¿dp
	} 
	cin &gt;&gt; s &gt;&gt; t;
	for(int i = 1; i &lt;= n + 20; i++){//åˆå§‹åŒ–
		dp[i] = 1147483646;
	}
	vis[t] = 1;
	dp[t] = 0;
	q.push(t);
	while(!q.empty()){//spfaæ¨¡æ¿ç¨åŠ æ”¹åŠ¨
		int now = q.front();
		q.pop();
		vis[now] = 0;
      //è¿™é‡Œçš„ä¸¤ä¸ªforå°±åˆ†åˆ«å¯¹åº”å‰é¢è½¬ç§»æ–¹ç¨‹çš„ä¸¤ç§æƒ…å†µ
		for(int i = head2[now]; ~i; i = e2[i].fail){
			if(dp[e2[i].v] &gt; dp[now] + 1){
				dp[e2[i].v] = dp[now] + 1;
				if(!vis[e2[i].v]){
					vis[e2[i].v] = 1;
					q.push(e2[i].v);
				}
			} 
		}
		int Max = 0;
		for(int i = head[now]; ~i; i = e[i].fail){
			Max = max(Max, dp[e[i].v]);
		}
		if(dp[now] &gt; Max){
			dp[now] = Max;
			if(!vis[now]){
				vis[now] = 1;
				q.push(now);
			}
		}
	}
	if(dp[s] != 1147483646)
	cout &lt;&lt; dp[s] &lt;&lt; endl;
	else cout &lt;&lt; -1 &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1074 é¶å½¢æ•°ç‹¬]]></title>
        <id>https://wbybl.github.io/post/p1074-ba-xing-shu-du</id>
        <link href="https://wbybl.github.io/post/p1074-ba-xing-shu-du">
        </link>
        <updated>2020-02-09T04:58:45.000Z</updated>
        <content type="html"><![CDATA[<p>è¿™é“é¢˜æ˜¯ä¸€é“dfså¥½é¢˜ï¼Œå¾ˆå¤šäººåœ¨é¢˜è§£é‡Œç”¨äº†å„ç§å‰ªæï¼Œä»¥åŠä¸€äº›å¥‡å¥‡æ€ªæ€ªçš„ä¼˜åŒ–ï¼Œè¿˜æœ‰å¤§ä½¬ç”¨çš„èˆè¹ˆé“¾ç®—æ³•ï¼Œè’Ÿè’»ä¸ä¼šèˆè¹ˆé“¾ï¼Œå‰ªæçš„æ•ˆæœä¹Ÿä¸æ˜¯å¾ˆå¥½ï¼Œåªèƒ½ç”¨ä¸€äº›ä¼˜åŒ–æ¥è¿‡è¿™é“é¢˜äº†ã€‚</p>
<p>è¿™é“é¢˜è™½ç„¶å·²ç»æœ‰å¾ˆå¤šé¢˜è§£äº†ï¼Œä½†æ˜¯æˆ‘è¿˜æ˜¯æ¥äº¤é¢˜è§£çš„åŸå› æ˜¯æˆ‘è§‰å¾—æˆ‘çš„ä»£ç è·‘çš„ï¼Œå¯ä»¥ç»™å¤§å®¶æä¾›ä¸€äº›å…³äºæœç´¢é¡ºåºçš„æ€è·¯ï¼Œ<s>å¸Œæœ›ç®¡ç†å‘˜ä¸è¦è®¤ä¸ºæˆ‘è¿™æ˜¯é‡å¤çš„è§£æ³•</s>ã€‚ä¸è¿‡æˆ‘æ•¢ä¿è¯ï¼Œæˆ‘çš„ä»£ç è·‘çš„ä¸€å®šæ¯”é™¤äº†æ‰“è¡¨é¢˜è§£ä»¥å¤–çš„é¢˜è§£è·‘çš„å¿«ã€‚</p>
<p><s>è¯´å®è¯ï¼Œè¿™é¢˜æ™®é€šå‰ªæä¹Ÿå¯ä»¥æ°´è¿‡</s>ï¼Œä½†æ˜¯æ—¢ç„¶æˆ‘ä»¬è¦è¿½æ±‚é€Ÿåº¦ï¼Œå°±ä¸èƒ½ä»…ä»…å±€é™äºæœ€ä¼˜æ€§ã€å¯è¡Œæ€§å‰ªæã€‚ç”»äº†å‡ å¼ å›¾ä»¥åå‘ç°ä¸€ä¸ªè§„å¾‹ï¼Œå…ˆæœç´¢çº¦æŸä¸ªæ•°å¤šçš„ç‚¹ï¼Œæ•ˆç‡æœ€é«˜ã€‚è¿™é‡Œçš„çº¦æŸä¸ªæ•°ï¼Œå°±æ˜¯è¿™ä¸ªç‚¹æ‰€åœ¨è¡Œã€åˆ—ã€å®«å·²ç»å¡«å¥½çš„æ•°çš„ä¸ªæ•°ä¹‹å’Œã€‚ï¼ˆå…·ä½“å†…å®¹è§ä¸‹å›¾ï¼‰</p>
<p>æ‰€ä»¥æˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªæ€è·¯ï¼Œä¸å¤„ç†å¥½æœç´¢é¡ºåºï¼Œä¹Ÿå°±æ˜¯ç»Ÿè®¡æ¯ä¸ªç‚¹çš„çº¦æŸä¸ªæ•°ï¼Œå…ˆæ‰¾åˆ°æœ€å¤šçš„ï¼Œç„¶åè®°å½•ä¸‹æ¥ï¼Œå‡è®¾å®ƒå·²ç»å¡«å¥½ï¼ˆæŠŠä»–æ‰€åœ¨çš„è¡Œã€åˆ—ã€å®«çš„çº¦æŸä¸ªæ•°åŠ ä¸€ï¼‰ï¼Œç„¶åç»§ç»­æ‰¾ç¬¬äºŒå¤šçš„å°±å¥½äº†ã€‚æœ€åæŒ‰ç…§è¿™ä¸ªé¡ºåºåœ¨æ¯æ¬¡dfsç»“æŸåæ‰¾åˆ°ä¸‹ä¸€ä¸ªå¡«æ•°çš„ç‚¹ï¼Œå°±okäº†ï¼Œè¿™æ ·å¯ä»¥è¾¾åˆ°æ€»æ•ˆç‡888ms,å·²ç»éå¸¸å¿«äº†ã€‚</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/pic/73082.png" alt="å¤§å®¶å¯ä»¥çœ‹ä¸€ä¸‹ï¼Œç¬¬ä¸€ä¸ªå°±æ˜¯é¢„å¤„ç†åçš„æœç´¢æ ‘ï¼Œç¬¬äºŒä¸ªæ˜¯éšä¾¿æœï¼Œå·®è·ä¸€ç›®äº†ç„¶" loading="lazy"></figure>
<p>æ˜¾ç„¶å…ˆæœç´¢å¯èƒ½æ€§ä¸º2çš„èŠ‚ç‚¹æ¯”å…ˆæœç´¢å¯èƒ½æ€§ä¸º4çš„æœç´¢æ ‘å°å¾ˆå¤šï¼Œå½“å¯èƒ½æ€§æ‰©å¤§åˆ°9*9=81æ—¶ï¼Œå·®è·ä¼šååˆ†æ˜æ˜¾ï¼Œæ•ˆç‡è‡ªç„¶ä¹Ÿå°±é«˜å¾ˆå¤šäº†</p>
<p>å¾ˆå¤šç»†èŠ‚è¯¦è§ä»£ç æ³¨é‡Šã€‚</p>
<p>å› ä¸ºå¾ˆå¤šäººåªæ˜¯é¢„å¤„ç†äº†åˆ—ï¼ŒæŒ‰ç…§åˆ—æ¯æ¬¡å¤„ç†9ä¸ªï¼Œæ‰€ä»¥æ•ˆç‡æ²¡æœ‰æˆ‘è¿™ç§å†™æ³•é«˜</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int ans[13][13];
int cntc[13],cntr[13],cntb[13];
int belong(int x,int y){//åˆ¤æ–­x,yå±äºå“ªä¸€ä¸ªå®«
	int h,l;
	if(x&lt;=3)h=1;
	else if(x&lt;=6)h=2;
	else h=3;
	if(y&lt;=3)l=1;
	else if(y&lt;=6)l=2;
	else l=3;
	return (h-1)*3+l;
}
pair&lt;int,int&gt; s[100];
int cnt=0;
int ANS=0;
int v[10][10]={{0,0,0,0,0,0,0,0,0,0},{0,6,6,6,6,6,6,6,6,6},{0,6,7,7,7,7,7,7,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,9,10,9,8,7,6,},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,7,7,7,7,7,7,6},{0,6,6,6,6,6,6,6,6,6}};
//è®°å½•æ¯ä¸€ä¸ªç‚¹çš„åˆ†æ•°
void calc(){
	int tot=0;
	for(int i=1;i&lt;=9;i++)
		for(int j=1;j&lt;=9;j++)
			tot+=ans[i][j]*v[i][j];
	ANS=max(ANS,tot);
}//æœç´¢å®Œæˆåè®¡ç®—ç­”æ¡ˆçš„å‡½æ•°
int col[20][20],row[20][20],block[20][20];
void dfs(int x,int y,int now){//ç®€å•çš„æœç´¢ï¼ŒæŒ‰ç…§æˆ‘ä»¬åœ¨mainå‡½æ•°ä¸­é¢„å¤„ç†çš„pair&lt;int,int&gt; sçš„é¡ºåºæœç´¢ï¼Œè¿™æ ·æ•ˆç‡æœ€é«˜
	if(now==cnt+1)calc();
	int b=belong(x,y);
	for(int i=1;i&lt;=9;i++){
		if(!col[x][i]&amp;&amp;!row[y][i]&amp;&amp;!block[b][i]){//åˆ¤æ–­æ˜¯ä¸æ˜¯å¯è¡Œ
			col[x][i]=row[y][i]=block[b][i]=1;//æ ‡è®°è®¿é—®
			ans[x][y]=i;
			dfs(s[now+1].first,s[now+1].second,now+1);
			col[x][i]=row[y][i]=block[b][i]=ans[x][y]=0;//å›æº¯
		}
	}
}
int vis[20][20];
int main(){
	for(int i=1;i&lt;=9;i++)
		for(int j=1;j&lt;=9;j++){
			cin&gt;&gt;ans[i][j];
			if(ans[i][j]!=0)vis[i][j]=1,cntc[i]++,cntr[j]++,cntb[belong(i,j)]++,col[i][ans[i][j]]=1,row[j][ans[i][j]]=1,block[belong(i,j)][ans[i][j]]=1;		
			else cnt++;
		}//è¿™é‡Œä¸ºé¢„å¤„ç†æ¯ä¸€ä¸ªç‚¹åœ¨è¡Œã€åˆ—ã€å®«ä¸­çš„é™åˆ¶ä¸ªæ•°
	for(int k=1;k&lt;=cnt;k++){
		int Max=0,px,py;
		for(int i=1;i&lt;=9;i++
			for(int j=1;j&lt;=9;j++)
				if(cntc[i]+cntr[j]+cntb[belong(i,j)]&gt;Max&amp;&amp;!vis[i][j])
				Max=cntc[i]+cntr[j]+cntb[belong(i,j)],px=i,py=j;
		s[k]=make_pair(px,py);
      //æ‰¾åˆ°å¯èƒ½æ€§æœ€å°‘çš„ç‚¹ï¼Œå¹¶å‡è®¾ä»–å·²ç»å¡«å¥½ï¼Œç»§ç»­æ‰¾ä¸‹ä¸€ä¸ª   
		cntc[px]++,cntr[py]++,cntb[belong(px,py)]++;
		vis[px][py]=1;
	//	cout&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;px&lt;&lt;&quot; &quot;&lt;&lt;py&lt;&lt;endl;	
	}
	dfs(s[1].first,s[1].second,1);//ä»ç¬¬ä¸€ä¸ªå¼€å§‹æœç´¢
	if(ANS!=0)
	cout&lt;&lt;ANS&lt;&lt;endl;
	else cout&lt;&lt;-1&lt;&lt;endl;//è¾“å‡ºç­”æ¡ˆ
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UVA1343 ã€æ—‹è½¬æ¸¸æˆ The Rotation Gameã€‘]]></title>
        <id>https://wbybl.github.io/post/uva1343-xuan-zhuan-you-xi-the-rotation-game</id>
        <link href="https://wbybl.github.io/post/uva1343-xuan-zhuan-you-xi-the-rotation-game">
        </link>
        <updated>2020-02-09T04:58:15.000Z</updated>
        <content type="html"><![CDATA[<p>è¿™é“é¢˜å¯ä»¥è¯´æ˜¯ida*çš„â€œæ¨¡æ¿&quot;é¢˜</p>
<p>ida*å°±æ˜¯è¿­ä»£åŠ æ·±æœç´¢+ä¼°ä»·ï¼Œæšä¸¾å±‚æ•°ï¼Œå¼€å§‹dfsï¼Œåˆ°æšä¸¾çš„å±‚æ•°å°±åœæ­¢ï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯æœ‰bfsçš„é¡ºåºï¼ˆé€Ÿåº¦ï¼‰ï¼Œå‰©ä¸‹äº†bfsçš„ç©ºé—´ã€‚</p>
<p>ä»€ä¹ˆæ˜¯ä¼°ä»·å‘¢ï¼Œä¼°ä»·å°±æ˜¯è®¡ç®—ä¸€ä¸ªå½“å‰æ–¹æ¡ˆçš„ä»·å€¼ï¼Œæ‰¾ä¸€ä¸ªæ¯”è¾ƒç†æƒ³çš„å…ˆæœç´¢ï¼Œè¿™æ ·ç†è®ºä¸Šå¯ä»¥åŠ é€Ÿæœç´¢çš„è¿‡ç¨‹ï¼Œä¸€ä¸ªå¥½çš„ä¼°ä»·å‡½æ•°å¯ä»¥è®©ä½ çš„æœç´¢ç›´æ¥æ‰¾åˆ°æ­£è§£ï¼ˆè™½ç„¶ä¸å¤§å¯èƒ½ï¼‰</p>
<p>è¿™é“é¢˜å°±æ˜¯å°†ä¸Šä¸‹å·¦å³çš„ç§»åŠ¨å½“æˆä¸€ç§çŠ¶æ€ï¼Œæ¯æ¬¡æœç´¢åŠ¨å“ªä¸€æ ¹ï¼Œä¼°ä»·å‡½æ•°ä¸ºä¸­é—´çš„å…«ä¸ªæ ¼å­æœ‰å‡ ä¸ªç›¸ç­‰çš„ï¼ˆåŸå› æ˜¯é¢˜ç›®æ±‚æœ€å°‘å‡ æ¬¡å¯ä»¥è®©ä¸­é—´çš„å˜æˆä¸€æ ·çš„æ•°ï¼‰ï¼Œæ¯æ¬¡è¿­ä»£åŠ æ·±å°±å¯ä»¥äº†ã€‚</p>
<p>è¿™é¢˜æœ‰å¾ˆå¤šç»†èŠ‚ï¼Œæ¯”å¦‚è¯´é¢˜ç›®ä¸­çš„è¯»å…¥éå¸¸ç„å­¦ï¼ŒæŒ‰ç…§1~24çš„é¡ºåºä»ä¸Šå¾€ä¸‹ï¼Œä»å·¦å¾€å³è¯»ï¼Œè¿™å°±éœ€è¦ä¸€äº›å¤„ç†æ¥è®¡ç®—å‡ºæ¯ä¸€æ ¹ä¸Šé¢çš„æ•°å­˜åœ¨å“ªé‡Œã€‚å…¶ä»–ç»†èŠ‚è¯¦è§ä»£ç æ³¨é‡Šã€‚</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//            1     2 
//            3     4
//      5  6  7  8  9 10 11
//			  12    13			
//      14 15 16 17 18 19 20
//            21    22
//            23    24   éšæ‰‹æ‰“ä¸‹çš„è‰ç¨¿ï¼Œç”¨æ¥å¯¹ç…§é¢˜ç›®ä¸­çš„è¾“å…¥ï¼Œå¤„ç†ç»†èŠ‚
int zhong[8]={7,8,9,12,13,16,17,18};//è®°å½•ä¸­å¿ƒå—è¯»å…¥çš„ä¸‹æ ‡
int a[100];
int b[8][7]={{1,3,7,12,16,21,23},{2,4,9,13,18,22,24},{11,10,9,8,7,6,5},{20,19,18,17,16,15,14},
{24,22,18,13,9,4,2},{23,21,16,12,7,3,1},{14,15,16,17,18,19,20},{5,6,7,8,9,10,11}};//è®°å½•8ç§æ“ä½œæŒªåŠ¨çš„ä¸‹æ ‡
int back[8]={5,4,7,6,1,0,3,2};
int count(int x){//æ•°åœ¨8ä¸ªä¸­å¿ƒå—ç§æœ‰å¤šå°‘ä¸ªx
	int cnt=0;
	for(int i=0;i&lt;=7;i++)if(a[zhong[i]]==x)cnt++;
	return cnt;
}
int calc(){//ç®—å‡ºä¸­å¿ƒå—ä¸­æœ‰å¤šå°‘ä¸ª1,2,3ï¼Œæ±‚å‡ºä»·å€¼ï¼ˆä¼°ä»·éƒ¨åˆ†ï¼‰
	return 8-max(max(count(1),count(2)),count(3));
}
void move(int n){//ä½¿ç”¨ç¬¬nç§æ“ä½œç§»åŠ¨ï¼Œè¿™é‡Œç”¨åˆ°äº†ä¹‹å‰å¤„ç†çš„æ¯ä¸€æ ¹ä¸Šé¢çš„ä¸‹æ ‡
	int q=a[b[n][0]];
	for(int i=1;i&lt;=6;i++){//å»æ‰æœ€åä¸€ä¸ªï¼Œå…±6ä¸ª
		a[b[n][i-1]]=a[b[n][i]];
	}
	a[b[n][6]]=q;//æ³¨æ„ç»†èŠ‚ï¼Œæœ€åä¸€ä¸ªéœ€è¦å•ç‹¬èµ‹å€¼
}
char c[100000];
void output(){//è¿™ä¸ªæ˜¯è°ƒè¯•ç”¨çš„è¾“å‡ºå‡½æ•°ï¼ŒæŒºå¤æ‚çš„ï¼ŒæŒ‘ä¸å‡ºæ¥çš„åŒå­¦ä»¬å¯ä»¥ç”¨ä»–è¾“å‡ºè°ƒè¯•
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[1]&lt;&lt;&quot;     &quot;&lt;&lt;a[2]&lt;&lt;endl;
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[3]&lt;&lt;&quot;     &quot;&lt;&lt;a[4]&lt;&lt;endl;
	cout&lt;&lt;a[5]&lt;&lt;&quot;  &quot;&lt;&lt;a[6]&lt;&lt;&quot;  &quot;&lt;&lt;a[7]&lt;&lt;&quot;  &quot;&lt;&lt;a[8]&lt;&lt;&quot;  &quot;&lt;&lt;a[9]&lt;&lt;&quot;  &quot;&lt;&lt;a[10]&lt;&lt;&quot;  &quot;&lt;&lt;a[11]&lt;&lt;endl;
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[12]&lt;&lt;&quot;     &quot;&lt;&lt;a[13]&lt;&lt;endl;
	cout&lt;&lt;a[14]&lt;&lt;&quot;  &quot;&lt;&lt;a[15]&lt;&lt;&quot;  &quot;&lt;&lt;a[16]&lt;&lt;&quot;  &quot;&lt;&lt;a[17]&lt;&lt;&quot;  &quot;&lt;&lt;a[18]&lt;&lt;&quot;  &quot;&lt;&lt;a[19]&lt;&lt;&quot;  &quot;&lt;&lt;a[20]&lt;&lt;endl;
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[21]&lt;&lt;&quot;     &quot;&lt;&lt;a[22]&lt;&lt;endl;
	cout&lt;&lt;&quot;      &quot;&lt;&lt;a[23]&lt;&lt;&quot;     &quot;&lt;&lt;a[24]; 
}
bool dfs(int now,int last,int limit){//æœç´¢å‡½æ•°ï¼Œè¿”å›å€¼æ˜¯æœæ²¡æœåˆ°è§£ï¼Œå¦‚æœæœåˆ°äº†è§£ï¼Œç­”æ¡ˆå°±æ˜¯è¿­ä»£åŠ æ·±çš„å±‚æ•°
	//output();
	//cout&lt;&lt;endl&lt;&lt;&quot;-------------------------------&quot;&lt;&lt;endl;
	if(calc()==0){//å¦‚æœå…¨éƒ¨ä¸€æ ·ï¼Œå°±æœ‰è§£
		return 1;
	}
	if(calc()+now&gt;limit)return 0;//å‰ªæï¼Œå¦‚æœæœ€å°‘æ­¥æ•°è¿˜è¶…è¿‡äº†å±‚æ•°é™åˆ¶ï¼Œå°±æ²¡æœ‰è§£äº†
	for(int i=0;i&lt;=7;i++){//æšä¸¾æ˜¯å“ªä¸€ç§ç§»åŠ¨
	//	cout&lt;&lt;(char)(i+'A')&lt;&lt;endl;
		//if(i==last)continue;
		move(i);
		c[now+1]=i+'A';//è®°å½•ç§»åŠ¨æ–¹æ¡ˆï¼Œå‡†å¤‡è¾“å‡º
		if(dfs(now+1,i,limit))return 1;//å¦‚æœæœåˆ°äº†è§£ï¼Œè¿”å›true
		move(back[i]); //è¿™é‡Œè¦å›æº¯ï¼Œå¾ˆé‡è¦çš„ç»†èŠ‚ï¼Œback[i]è¡¨ç¤ºiçš„é€†æ“ä½œ
	}
	return 0;
}
int main(){
	//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    while(1){
		cin&gt;&gt;a[1];
		if(a[1]==0)return 0;
		for(int i=2;i&lt;=24;i++)cin&gt;&gt;a[i];
		if(calc()==0)cout&lt;&lt;&quot;No moves needed&quot;&lt;&lt;endl&lt;&lt;a[zhong[1]]&lt;&lt;endl;//ç»†èŠ‚ï¼Œå¦‚æœä¸éœ€è¦ç§»åŠ¨ï¼Œç›´æ¥è¾“å‡º
		else{
			int ans=1;
			while(1){//è¿­ä»£åŠ æ·±ï¼Œæšä¸¾å±‚æ•°
				if(dfs(0,-1,ans)){//å¦‚æœåœ¨anså±‚å†…æœ‰è§£ï¼Œç­”æ¡ˆä¸ºans
					break;
				}
				ans++;
			}
			for(int i=1;i&lt;=ans;i++)cout&lt;&lt;c[i];//è¾“å‡ºç§»åŠ¨çš„æ–¹æ¡ˆ
			cout&lt;&lt;endl&lt;&lt;a[zhong[1]]&lt;&lt;endl;//è¾“å‡ºä¸­å¿ƒå—é¢œè‰²
		}	
    }
}
</code></pre>
]]></content>
    </entry>
</feed>