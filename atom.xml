<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wbybl.github.io</id>
    <title>我不要爆零的博客</title>
    <updated>2020-02-22T11:05:25.459Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wbybl.github.io"/>
    <link rel="self" href="https://wbybl.github.io/atom.xml"/>
    <logo>https://wbybl.github.io/images/avatar.png</logo>
    <icon>https://wbybl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 我不要爆零的博客</rights>
    <entry>
        <title type="html"><![CDATA[UOJ#67新年的毒瘤]]></title>
        <id>https://wbybl.github.io/post/uoj67-xin-nian-de-du-liu</id>
        <link href="https://wbybl.github.io/post/uoj67-xin-nian-de-du-liu">
        </link>
        <updated>2020-02-22T10:59:27.000Z</updated>
        <content type="html"><![CDATA[<p>题意：找出一个点，使得删掉后成为一棵树<br>
一棵n个点的树有n-1条边，所以删掉点后需要有n-2条边<br>
所以找出所有m-n-2度数的点即可<br>
但是要保证删掉后联通，所以割点要排除</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[tarjan求割点]]></title>
        <id>https://wbybl.github.io/post/tarjan-qiu-ge-dian</id>
        <link href="https://wbybl.github.io/post/tarjan-qiu-ge-dian">
        </link>
        <updated>2020-02-22T10:50:35.000Z</updated>
        <content type="html"><![CDATA[<p>首先，我们要了解一下割点的定义：把这个点去掉之后，这个点所在的联通块就会被分成若干个联通块。</p>
<p>既然这样，也就是说，只要这个节点某一个子节点所到达的节点的dfsdfsdfs序大于等于该节点的dfsdfsdfs序，即它的这个子节点无法到达dfsdfsdfs序小于该节点的节点，就说明它是一个割点了。</p>
<p>而对于一个联通块第一个访问的节点，则需特判，如果它在遍历完一个节点所能遍历到的所有节点，还能找到没有被遍历过的节点，就说明它是一个割点。</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
struct edge{
	int v,fail;
	edge(){
	}
	edge(int a,int c){
		v=a;
		fail=c;
	}
}e[200100];
int len,head[200100];
int num,vis[200100];
void add(int a,int b){
	e[len]=edge(b,head[a]);
	head[a]=len++;
} 
int ti,dfn[200100],low[200100];
void tarjan(int now,int fa){
	low[now]=dfn[now]=++ti;
	int cnt=0; 
	for(int i=head[now];~i;i=e[i].fail){
		if(e[i].v==fa)
		    continue;
		if(!dfn[e[i].v]){
		    cnt++;
			tarjan(e[i].v,now);
			low[now]=min(low[now],low[e[i].v]);
			if(low[e[i].v]&gt;=dfn[now]){
				if(fa&gt;0) 
				    vis[now]=1,num++; 
			}
		}
		else
			low[now]=min(low[now],dfn[e[i].v]);
	}
	if(fa&lt;0&amp;&amp;cnt&gt;=2) 
	vis[now]=1,num++;
} 
int main(){
	//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);
	memset(head,-1,sizeof(head));
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++){
		int a,b,c;
		cin&gt;&gt;a&gt;&gt;b;
		add(a,b);
		add(b,a); 
	}
	for(int i=1;i&lt;=n;i++){
		if(!dfn[i])tarjan(i,-1);
	}
	//cout&lt;&lt;num&lt;&lt;endl;
	int cnt=0;
	for(int i=1;i&lt;=n;i++)
		if(vis[i])cnt++;
		//cout&lt;&lt;i&lt;&lt;&quot; &quot;;
	cout&lt;&lt;cnt&lt;&lt;endl;
	for(int i=1;i&lt;=n;i++){
		if(vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;
	} 
	cout&lt;&lt;endl;
	return 0; 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Boruvka最小生成树&&复杂度对比]]></title>
        <id>https://wbybl.github.io/post/boruvka-zui-xiao-sheng-cheng-shu-andfu-za-du-dui-bi</id>
        <link href="https://wbybl.github.io/post/boruvka-zui-xiao-sheng-cheng-shu-andfu-za-du-dui-bi">
        </link>
        <updated>2020-02-13T10:58:32.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://wbybl.github.io/post-images/1581657203168.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://wbybl.github.io/post-images/1581591548857.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[访问量]]></title>
        <id>https://wbybl.github.io/post/test</id>
        <link href="https://wbybl.github.io/post/test">
        </link>
        <updated>2020-02-13T01:46:54.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://www.harlanc.vip/generatepic?userid=adbb84c0-991c-4aea-bf24-0d60c4e2e998" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF316F3 【Suns and Rays】]]></title>
        <id>https://wbybl.github.io/post/cf316f3-suns-and-rays</id>
        <link href="https://wbybl.github.io/post/cf316f3-suns-and-rays">
        </link>
        <updated>2020-02-12T01:43:58.000Z</updated>
        <content type="html"><![CDATA[<p>其实这题的F1，F2，F3我都是一份代码过得。<br>
总体思路都是一样的，不受题目中椭圆、旋转的影响<br>
这题难点在于如何分离出太阳的光芒和主体，想了半天后在网上看到一个神奇的思路<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/fe4a498z.png" alt="开始是这样的" loading="lazy"><br>
然后我们先“缩小”，就是如果一个黑色旁边有白色，就把他变成白色，当然一次只能变一层，所以我们可以先拿一个数组存下来，然后枚举一遍，再放回数组里。<br>
当然一遍缩点不够，我们需要进行4次缩小，然后太阳就会变成这个图中黄色的部分，当然要存在两个数组里，我只是放在一起，方便对比<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/ix2whzga.png" alt="" loading="lazy"></p>
<p>但是这样，我们如果黄色和黑色相减，得出来的并不是分离好的光芒，而是光芒和一圈黑色，还是无法判断</p>
<p>所以我们要用缩小的逆操作，“展开”</p>
<p>在缩点后的数组中操作，如果一个点周围有黄色，就把它变成黄色，这样展开8次，就会变成左边的两张图，下面的是展开后的，上面的是原图<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/vkb6ebhi.png" alt="" loading="lazy"></p>
<p>把这两张图相减，就得到了右边的图，相减的原则：只要黑色和黄色重合，就变成白色，这样在结合原图，用几次flood fill遍历一下，就可以解决这道题了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
bool a[2000][2000],b[2000][2000],c[2000][2000];
int n,m;
void jian(){//缩小
	memcpy(c,b,sizeof(b));
	for(int i=1;i&lt;=n-2;i++){
		for(int j=1;j&lt;=m-2;j++){
			if(!b[i+1][j]||!b[i][j+1]||!b[i-1][j]||!b[i][j-1])
			c[i][j]=0; 
		} 
	}
	memcpy(b,c,sizeof(b));
}
void jia(){//展开
	memcpy(c,b,sizeof(b));
	for(int i=1;i&lt;=n-2;i++){
		for(int j=1;j&lt;=m-2;j++){
			if(b[i+1][j]||b[i][j+1]||b[i-1][j]||b[i][j-1]){
				c[i][j]=1;
			}
		}
	}
	memcpy(b,c,sizeof(b));
}
bool vis[2000][2000];
int d[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
int cnt,ans[20000];
pair&lt;int,int&gt; q1[6000000],q2[6000000];
int h1,t1,h2,t2;
bool count(int x,int y){//判断光芒
	h1=1;
	t1=1;
	q1[t1++]=make_pair(x,y);
	a[x][y]=0;
	int cnt=0;
	while(h1&lt;t1){
		x=q1[h1].first;
		y=q1[h1].second;
		h1++;
		for(int i=0;i&lt;4;i++){
			int tx=x+d[i][0],ty=y+d[i][1];
			if(tx&gt;n||tx&lt;0||ty&gt;m||ty&lt;0)continue;
			if(a[tx][ty]){
				a[tx][ty]=0;
				cnt++;
				q1[t1++]=make_pair(tx,ty);
			}
		}
	}
	if(cnt&gt;5)return 1;
	else return 0;
}
int bfs(int x,int y){//与上面的count，下面的数太阳，上面的判断光芒
	h2=1;
	t2=1;
	q2[t2++]=make_pair(x,y);
	b[x][y]=0;
	int an=0;
	while(h2&lt;t2){
		x=q2[h2].first;
		y=q2[h2].second;
		h2++;
		for(int i=0;i&lt;4;i++){
			int tx=x+d[i][0],ty=y+d[i][1];
			if(a[tx][ty]){
				an+=count(tx,ty);
			}
			if(b[tx][ty]){
				b[tx][ty]=0;
				q2[t2++]=make_pair(tx,ty);
			}
		}
	} 
	return an;
}
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c&lt;'0'||c&gt;'9')
	{
		if(c=='-')
			flag=1;
		c=getchar();
	}
    while(c&gt;='0'&amp;&amp;c&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';
		c=getchar();
	}
    return flag?-x:x;
}
int main(){
	//freopen(&quot;1.in&quot;,&quot;r&quot;,stdin);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			int C=read();
			a[i][j]=b[i][j]=C;
		}
	}
	n+=2;
	m+=2;//避免越界
	for(int i=1;i&lt;=4;i++)jian();//缩小
//	for(int i=1;i&lt;=n;i++){
//		for(int j=1;j&lt;=m;j++)cout&lt;&lt;b[i][j];
//		cout&lt;&lt;endl;
//	}
	for(int i=1;i&lt;=8;i++)jia();//展开
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;m;j++){
			if(b[i][j])a[i][j]=0;//相减，得出单独的光芒
		}
	} 
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;m;j++){
			if(b[i][j]){
				ans[++cnt]=bfs(i,j);//分别遍历
			}
		}
	}
	sort(ans+1,ans+cnt+1);//按要求排序输出答案
	cout&lt;&lt;cnt&lt;&lt;endl;
	for(int i=1;i&lt;=cnt;i++){
		cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;
	} 
	cout&lt;&lt;endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[带权并查集]]></title>
        <id>https://wbybl.github.io/post/dai-quan-bing-cha-ji</id>
        <link href="https://wbybl.github.io/post/dai-quan-bing-cha-ji">
        </link>
        <updated>2020-02-11T12:26:03.000Z</updated>
        <content type="html"><![CDATA[<p>每一条边记录每个节点到根节点的一个权值，这个权值由具体问题决定<br>
考虑权值需要注意两个问题<br>
1.每个节点记录的都是与根节点的权值，路径压缩时，权值也应该更新</p>
<pre><code>int find(int x){
    if(x!=fa[x]){
        int t=fa[x];
        fa[x]=find(fa[x]);
        v[x]+=v[t];
    }
    return fa[x];
}
</code></pre>
<p>2.并查集做合并时，权值应该更新，因为两个并查集的根节点不同</p>
<pre><code>int px=find(x);
int py=find(y);
if(px!=py){
    fa[px]=py;
    v[px]=-v[x]+v[y]+s;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2-SAT]]></title>
        <id>https://wbybl.github.io/post/2-sat</id>
        <link href="https://wbybl.github.io/post/2-sat">
        </link>
        <updated>2020-02-11T11:19:55.000Z</updated>
        <content type="html"><![CDATA[<p>有两个集合，给出n组限定关系，每一个元素要放进一个集合里，限制关系（a,b)为一个集合选择a就不能选择b。输出一种分组方案</p>
<p>不放假设元素a对应的集合中的另一个元素为a'<br>
矛盾关系可以转化为：选择a就必须选择b'<br>
同样，选择b就必须选择a'</p>
<p>这个”必须“关系是可以传递的，所以可以用图论模型来做</p>
<p>对于一个强连通分量中的所有元素，只要一个选了，就必须选择剩下所有的元素</p>
<p>如果存在a使得a和a'在一个强联通分量里，无解</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[luoguP2341【模板】强连通分量 / [HAOI2006]受欢迎的牛]]></title>
        <id>https://wbybl.github.io/post/luogup2341mo-ban-qiang-lian-tong-fen-liang-haoi2006shou-huan-ying-de-niu</id>
        <link href="https://wbybl.github.io/post/luogup2341mo-ban-qiang-lian-tong-fen-liang-haoi2006shou-huan-ying-de-niu">
        </link>
        <updated>2020-02-10T06:08:51.000Z</updated>
        <content type="html"><![CDATA[<p>tarjan就不讲了<br>
首先缩点，然后发现明星只可能是缩点重新建图后，出度为零的点，否则他自己无法欢迎他自己<br>
但是如果出度为零的点&gt;=2个，就没有受欢迎的牛了</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
using namespace std;
int color[200000],cnt=0;
struct edge{
    int v,fail;
    edge(){
    }
    edge(int a,int b){
        v=a;
        fail=b;
    }
}e[400000];
int n,m,head[200000],len;
int N[200000];
void init(){
    len=0;
    memset(head,-1,sizeof(head));
}
int dfn[200000],low[200000],vis[200000];
void add(int a,int b){
    e[len]=edge(b,head[a]);
    head[a]=len++;
}
int Time;
stack&lt;int&gt; s;
void calc(){
	int t=s.top();
	s.pop();
	color[t]=cnt;
	N[cnt]++;
	vis[t]=0;
} 
void tarjan(int x){
	vis[x]=1;
	s.push(x);
	dfn[x]=low[x]=++Time;
	for(int i=head[x];~i;i=e[i].fail){
		if(!dfn[e[i].v]){
			tarjan(e[i].v);
			low[x]=min(low[x],low[e[i].v]);
		}else if(vis[e[i].v])low[x]=min(low[x],dfn[e[i].v]);
	}
	if(dfn[x]==low[x]){
		cnt++;
		while(s.top()!=x)calc();
		calc();
	}
}
int in[100000]; 
int x[100000],y[100000];
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	init();
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;x[i]&gt;&gt;y[i];
		add(x[i],y[i]);
	}
	for(int i=1;i&lt;=n;i++){
		if(!color[i])tarjan(i);
	}
	int ans=0;
	int tot=0;
	for(int i=1;i&lt;=m;i++){
	//	cout&lt;&lt;color[i]&lt;&lt;endl;
		if(color[x[i]]!=color[y[i]]){
			in[color[x[i]]]++;
	//		cout&lt;&lt;color[x[i]]&lt;&lt;&quot; to&quot;&lt;&lt;color[y[i]]&lt;&lt;endl;
		}
	}	
	for(int i=1;i&lt;=cnt;i++){
		if(!in[i]){
			tot++;
			ans=N[i];
		}
	}
//	cout&lt;&lt;cnt&lt;&lt;endl;
	if(tot==1)
	cout&lt;&lt;ans&lt;&lt;endl;
	else cout&lt;&lt;0&lt;&lt;endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[luoguP1471 方差]]></title>
        <id>https://wbybl.github.io/post/luogup1471-fang-chai</id>
        <link href="https://wbybl.github.io/post/luogup1471-fang-chai">
        </link>
        <updated>2020-02-09T09:07:14.000Z</updated>
        <content type="html"><![CDATA[<p>这道题一眼线段树<br>
然而并不太好想怎么维护😭<br>
图片引用自luogu@远航之曲<br>
<img src="https://wbybl.github.io/post-images/1581239342596.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://wbybl.github.io/post-images/1581239377432.png" alt="" loading="lazy"></figure>
<p>总体思路就是记录区间和，还有区间的平方和，通过图2来进行平方和的标记下传，用图一的式子来算出方差</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
using namespace std;
inline int read(){
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c&lt;'0'||c&gt;'9'){
		if(c=='-')
			flag=1;
		c=getchar();
	}
    while(c&gt;='0'&amp;&amp;c&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';
		c=getchar();
	}
    return flag?-x:x;
}
double tree1[500100];
double tree2[500100];
double lazy[500100],a[500010];
void build(int l,int r,int t){
	if(l==r){
		tree1[t]=a[l];
		tree2[t]=a[l]*a[l];
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,t*2);
	build(mid+1,r,t*2+1);
	tree1[t]=tree1[t*2]+tree1[t*2+1];
	tree2[t]=tree2[t*2]+tree2[t*2+1];
}
void push(int t,int len){
	if(lazy[t]==0)return;
	tree2[t*2]+=(len-len/2)*lazy[t]*lazy[t]+2*tree1[t*2]*lazy[t];
	tree2[t*2+1]+=(len/2)*lazy[t]*lazy[t]+2*tree1[t*2+1]*lazy[t];
	tree1[t*2]+=(len-len/2)*lazy[t];
	tree1[t*2+1]+=(len/2)*lazy[t];
	lazy[t*2]+=lazy[t];
	lazy[t*2+1]+=lazy[t];
	lazy[t]=0;
	return;
}
double ans;
void query(int ll,int rr,int l,int r,int t,int flag){
	if(ll&lt;=l&amp;&amp;r&lt;=rr){
		if(flag==1)ans+=tree1[t];
		else ans+=tree2[t]; 
		return;
	}
	push(t,r-l+1);
	int mid=(l+r)/2;
	if(ll&lt;=mid)query(ll,rr,l,mid,t*2,flag);
	if(rr&gt;mid)query(ll,rr,mid+1,r,t*2+1,flag);
	tree1[t]=tree1[t*2]+tree1[t*2+1];
	tree2[t]=tree2[t*2]+tree2[t*2+1];
}
void modify(int ll,int rr,int l,int r,double c,int t){
	if(ll&lt;=l&amp;&amp;r&lt;=rr){
		lazy[t]+=c;
		tree2[t]+=2*c*tree1[t]+c*c*(r-l+1);
		tree1[t]+=(r-l+1)*c;
		return;
	}
	push(t,r-l+1);
	int mid=(l+r)/2;
	if(ll&lt;=mid)modify(ll,rr,l,mid,c,t*2);
	if(rr&gt;mid)modify(ll,rr,mid+1,r,c,t*2+1);
	tree1[t]=tree1[t*2]+tree1[t*2+1];
	tree2[t]=tree2[t*2]+tree2[t*2+1];
}
int main(){
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	build(1,n,1);
	while(m--){
		int opt;
		cin&gt;&gt;opt;
		if(opt==1){
			int a,b;
			double c;
			cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
			modify(a,b,1,n,c,1);
		}else if(opt==2){
			int a,b;
			cin&gt;&gt;a&gt;&gt;b;
			ans=0;
			query(a,b,1,n,1,1);
			double avg=ans;
			avg=avg/(b-a+1);
			printf(&quot;%.4lf\n&quot;,avg);
		}else if(opt==3){
			int a,b;
			cin&gt;&gt;a&gt;&gt;b;
			ans=0;
			query(a,b,1,n,1,1);
			double avg=ans;
			avg=avg/(b-a+1);
			ans=0;
			query(a,b,1,n,1,2);
			double sum=ans;
			sum=sum/(b-a+1);
			double ANS=sum-avg*avg;
			printf(&quot;%.4lf\n&quot;,ANS); 
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[luoguP3953 逛公园]]></title>
        <id>https://wbybl.github.io/post/luogup3953-guang-gong-yuan</id>
        <link href="https://wbybl.github.io/post/luogup3953-guang-gong-yuan">
        </link>
        <updated>2020-02-09T09:01:00.000Z</updated>
        <content type="html"><![CDATA[<p>很经典（😏）的一道题，发现k不是很大，可以枚举k，然后跑一个记忆化搜索统计答案<br>
思路简单，但是写起来有些难度</p>
<p>可以dp来做，用f[i][j]表示从n到i的距离&lt;最短距离+k的方案数，对于每一条边都尝试走，而这个状态可以表示为u-&gt;v: d[u]-d[v]+k-len[u-&gt;v];最后西格玛一下就over了<br>
挺神奇的哈</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;pair&lt;int,int&gt; &gt; v1[1100000],v2[1100000];
inline int read(){
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c&lt;'0'||c&gt;'9'){
		if(c=='-')
			flag=1;
		c=getchar();
	}
    while(c&gt;='0'&amp;&amp;c&lt;='9'){
		x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';
		c=getchar();
	}
    return flag?-x:x;
}
int dis[1100000],n,m;
void spfa(int s){
	for(int i=1;i&lt;=n;i++){
		dis[i]=2147483646;
	}
	queue&lt;int&gt; q;
	dis[s]=0;
	q.push(s);
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=0;i&lt;v1[now].size();i++){
			int v=v1[now][i].first,w=v1[now][i].second;
			if(dis[v]&gt;dis[now]+w){
				dis[v]=dis[now]+w;
				q.push(v); 
			}
		}
	}
}
int k,dp[100100][55],mod;
bool vis[100100][55];
int dfs(int x,int left){
	if(left&lt;0||left&gt;k)return 0;
	int ans=0;
	if(vis[x][left]){
		vis[x][left]=0;
		return -1;
	}
	if(dp[x][left]!=-1)return dp[x][left];
	vis[x][left]=1;
	for(int i=0;i&lt;v2[x].size();i++){
        int sum=dfs(v2[x][i].first,dis[x]+left-dis[v2[x][i].first]-v2[x][i].second);
	    if(sum==-1){
            vis[x][left]=0;
            return -1;
        }
        ans=(ans+sum)%mod;
	}
	vis[x][left]=0;
    if(x==1&amp;&amp;left==0)ans++;
    dp[x][left]=ans;
    return ans;
}
int main(){
	ios::sync_with_stdio(0);
	int t;
	cin&gt;&gt;t;
	while(t--){
		//n=read();
		//m=read();
		//k=read();
		//mod=read();
		cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;mod;
		for(int i=1;i&lt;=n;i++){
			v1[i].clear();
			v2[i].clear();
		}
		for(int i=1;i&lt;=m;i++){
			int u,v,w;
		//	u=read();
		//	v=read();
		//	w=read();
			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
			v1[u].push_back(make_pair(v,w));
			v2[v].push_back(make_pair(u,w));
		} 
		spfa(1);
		memset(dp,-1,sizeof(dp));
		int ans=0;
		for(int i=0;i&lt;=k;i++){
			int tmp=dfs(n,i);
			if(tmp==-1){
				ans=-1;
				break;
			}
			ans=(ans+tmp)%mod; 
		}
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>